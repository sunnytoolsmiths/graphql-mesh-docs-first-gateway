import { Kind } from 'graphql';
import { MapperKind, mapSchema } from '@graphql-tools/utils';
export function getArgsFromKeysForFederation(representations) {
    return { representations };
}
export function getKeyForFederation(root) {
    return root;
}
export function getKeyFnForFederation(typeName, keys) {
    if (keys.some(key => key.includes('{'))) {
        return getKeyForFederation;
    }
    const allKeyProps = keys.flatMap(key => key.split(' '));
    if (allKeyProps.length > 1) {
        const typeNameEntry = ['__typename', typeName];
        return function keyFn(root) {
            return Object.fromEntries(allKeyProps.map(key => [key, root[key]]).concat([typeNameEntry]));
        };
    }
    const keyProp = allKeyProps[0];
    return function keyFn(root) {
        return {
            __typename: root['__typename'],
            [keyProp]: root[keyProp],
        };
    };
}
export function getCacheKeyFnFromKey(key) {
    if (key.includes('{')) {
        return function cacheKeyFn(root) {
            return JSON.stringify(root);
        };
    }
    const keyProps = key.split(' ');
    if (keyProps.length > 1) {
        return function cacheKeyFn(root) {
            return keyProps.map(key => root[key]).join(' ');
        };
    }
    return function cacheKeyFn(root) {
        return root[key];
    };
}
const internalTypeNames = ['_Entity', '_Any', '_FieldSet', '_Service'];
export function filterInternalFieldsAndTypes(finalSchema) {
    return mapSchema(finalSchema, {
        [MapperKind.TYPE]: type => {
            if (internalTypeNames.includes(type.name) || type.name.startsWith('link__')) {
                return null;
            }
            return type;
        },
        [MapperKind.COMPOSITE_FIELD]: fieldConfig => {
            if (fieldConfig.astNode?.directives?.some(d => d.name.value === 'inaccessible')) {
                return null;
            }
            return fieldConfig;
        },
        [MapperKind.QUERY_ROOT_FIELD]: (fieldConfig, fieldName) => {
            if (fieldName === '_entities') {
                return null;
            }
            return fieldConfig;
        },
        [MapperKind.ENUM_VALUE]: valueConfig => {
            if (valueConfig.astNode?.directives?.some(d => d.name.value === 'inaccessible')) {
                return null;
            }
        },
        [MapperKind.ARGUMENT]: argConfig => {
            if (argConfig.astNode?.directives?.some(d => d.name.value === 'inaccessible')) {
                return null;
            }
            return argConfig;
        },
    });
}
export function getNamedTypeNode(typeNode) {
    if (typeNode.kind !== Kind.NAMED_TYPE) {
        return getNamedTypeNode(typeNode.type);
    }
    return typeNode;
}
