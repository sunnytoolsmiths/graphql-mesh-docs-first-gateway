"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNamedTypeNode = exports.filterInternalFieldsAndTypes = exports.getCacheKeyFnFromKey = exports.getKeyFnForFederation = exports.getKeyForFederation = exports.getArgsFromKeysForFederation = void 0;
const graphql_1 = require("graphql");
const utils_1 = require("@graphql-tools/utils");
function getArgsFromKeysForFederation(representations) {
    return { representations };
}
exports.getArgsFromKeysForFederation = getArgsFromKeysForFederation;
function getKeyForFederation(root) {
    return root;
}
exports.getKeyForFederation = getKeyForFederation;
function getKeyFnForFederation(typeName, keys) {
    if (keys.some(key => key.includes('{'))) {
        return getKeyForFederation;
    }
    const allKeyProps = keys.flatMap(key => key.split(' '));
    if (allKeyProps.length > 1) {
        const typeNameEntry = ['__typename', typeName];
        return function keyFn(root) {
            return Object.fromEntries(allKeyProps.map(key => [key, root[key]]).concat([typeNameEntry]));
        };
    }
    const keyProp = allKeyProps[0];
    return function keyFn(root) {
        return {
            __typename: root['__typename'],
            [keyProp]: root[keyProp],
        };
    };
}
exports.getKeyFnForFederation = getKeyFnForFederation;
function getCacheKeyFnFromKey(key) {
    if (key.includes('{')) {
        return function cacheKeyFn(root) {
            return JSON.stringify(root);
        };
    }
    const keyProps = key.split(' ');
    if (keyProps.length > 1) {
        return function cacheKeyFn(root) {
            return keyProps.map(key => root[key]).join(' ');
        };
    }
    return function cacheKeyFn(root) {
        return root[key];
    };
}
exports.getCacheKeyFnFromKey = getCacheKeyFnFromKey;
const internalTypeNames = ['_Entity', '_Any', '_FieldSet', '_Service'];
function filterInternalFieldsAndTypes(finalSchema) {
    return (0, utils_1.mapSchema)(finalSchema, {
        [utils_1.MapperKind.TYPE]: type => {
            if (internalTypeNames.includes(type.name) || type.name.startsWith('link__')) {
                return null;
            }
            return type;
        },
        [utils_1.MapperKind.COMPOSITE_FIELD]: fieldConfig => {
            if (fieldConfig.astNode?.directives?.some(d => d.name.value === 'inaccessible')) {
                return null;
            }
            return fieldConfig;
        },
        [utils_1.MapperKind.QUERY_ROOT_FIELD]: (fieldConfig, fieldName) => {
            if (fieldName === '_entities') {
                return null;
            }
            return fieldConfig;
        },
        [utils_1.MapperKind.ENUM_VALUE]: valueConfig => {
            if (valueConfig.astNode?.directives?.some(d => d.name.value === 'inaccessible')) {
                return null;
            }
        },
        [utils_1.MapperKind.ARGUMENT]: argConfig => {
            if (argConfig.astNode?.directives?.some(d => d.name.value === 'inaccessible')) {
                return null;
            }
            return argConfig;
        },
    });
}
exports.filterInternalFieldsAndTypes = filterInternalFieldsAndTypes;
function getNamedTypeNode(typeNode) {
    if (typeNode.kind !== graphql_1.Kind.NAMED_TYPE) {
        return getNamedTypeNode(typeNode.type);
    }
    return typeNode;
}
exports.getNamedTypeNode = getNamedTypeNode;
