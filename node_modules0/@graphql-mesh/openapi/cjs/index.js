"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const store_1 = require("@graphql-mesh/store");
const string_interpolation_1 = require("@graphql-mesh/string-interpolation");
const utils_1 = require("@graphql-mesh/utils");
const openapi_1 = require("@omnigraph/openapi");
class OpenAPIHandler {
    constructor({ name, config, baseDir, store, pubsub, logger, importFn, }) {
        this.name = name;
        this.config = config;
        this.baseDir = baseDir;
        this.schemaWithAnnotationsProxy = store.proxy('schemaWithAnnotations', store_1.PredefinedProxyOptions.GraphQLSchemaWithDiffing);
        this.bundleProxy = store.proxy('jsonSchemaBundle', store_1.PredefinedProxyOptions.JsonWithoutValidation);
        this.pubsub = pubsub;
        this.importFn = importFn;
        this.logger = logger;
    }
    async getNonExecutableSchema({ interpolatedSource }) {
        if (interpolatedSource.endsWith('.graphql')) {
            this.logger.info(`Fetching GraphQL Schema with annotations`);
            const sdl = await (0, utils_1.readFileOrUrl)(interpolatedSource, {
                allowUnknownExtensions: true,
                cwd: this.baseDir,
                fetch: this.fetchFn,
                importFn: this.importFn,
                logger: this.logger,
                headers: this.config.schemaHeaders,
            });
            return (0, graphql_1.buildSchema)(sdl, {
                assumeValidSDL: true,
                assumeValid: true,
            });
        }
        return this.schemaWithAnnotationsProxy.getWithSet(async () => {
            this.logger.info(`Generating GraphQL schema from OpenAPI schema`);
            const schema = await (0, openapi_1.loadNonExecutableGraphQLSchemaFromOpenAPI)(this.name, {
                ...this.config,
                source: interpolatedSource,
                cwd: this.baseDir,
                fetch: this.fetchFn,
                logger: this.logger,
                selectQueryOrMutationField: this.config.selectQueryOrMutationField?.map(({ type, fieldName }) => ({
                    type: type.toLowerCase(),
                    fieldName,
                })),
                pubsub: this.pubsub,
                bundle: this.config.bundle,
            });
            if (this.config.bundle) {
                await this.bundleProxy.set(schema.extensions.bundle);
            }
            return schema;
        });
    }
    async getMeshSource({ fetchFn }) {
        const interpolatedSource = string_interpolation_1.stringInterpolator.parse(this.config.source, {
            env: process.env,
        });
        this.fetchFn = fetchFn;
        this.logger.debug('Getting the schema with annotations');
        const nonExecutableSchema = await this.getNonExecutableSchema({
            interpolatedSource,
        });
        this.logger.info(`Processing annotations for the execution layer`);
        const schemaWithDirectives = (0, openapi_1.processDirectives)({
            ...this.config,
            schema: nonExecutableSchema,
            pubsub: this.pubsub,
            logger: this.logger,
            globalFetch: fetchFn,
        });
        return {
            schema: schemaWithDirectives,
        };
    }
}
exports.default = OpenAPIHandler;
